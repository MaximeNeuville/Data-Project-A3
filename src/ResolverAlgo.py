# import numpy as np
# import DataSetGenerator as Dsg
import time

'''
takes params the cost matrix generated by random_symmetric_matrix() and compares combinations 
of roots (tests if the new combination is better than the old route)
'''


def cost_change(cost_mat, n1, n2, n3, n4):
    return cost_mat[n1][n3] + cost_mat[n2][n4] - cost_mat[n1][n2] - cost_mat[n3][n4]


def two_opt(route, cost_mat):

    start_time = time.time()
    best = route
    improved = True
    while improved:
        improved = False
        for i in range(1, len(route) - 2):
            for j in range(i + 1, len(route)):
                if j - i == 1:
                    continue
                '''
                tests if the new combination of the new root can be improved
                '''
                if cost_change(cost_mat, best[i - 1], best[i], best[j - 1], best[j]) < 0:
                    best[i:j] = best[j - 1:i - 1:-1]
                    improved = True
        route = best

    # calculate wheight of best route
    route_wheight = x = 0

    for i in range(0, len(best)):
        route_wheight = route_wheight + cost_mat[x][best[i]]
        x = best[i]

    nb_city = len(cost_mat)
    clock = time.time() - start_time

    return [nb_city, clock, route_wheight, best]


'''
if __name__ == '__main__':
    # nodes = 1000

    cityNumber = input("Please enter the number of cities that you want : ")

    init_route = list(range(cityNumber))
    # print(init_route)
    mat = Dsg.random_symmetric_matrix(cityNumber)
    mat = list(mat)
    best_route = two_opt(init_route, mat)
    print(best_route)
'''
